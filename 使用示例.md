# 后台优化工具使用示例

## 1. SSE连接优化

### 原始代码（UserNotification.vue）
```vue
<script setup lang="ts">
// 原始实现
let eventSource: EventSource | null = null

function startSSEMessager() {
  setTimeout(() => {
    eventSource = new EventSource(`${import.meta.env.VITE_API_BASE_URL}system/message`)
    eventSource.addEventListener('message', event => {
      if (event.data) {
        const noti: SystemNotification = JSON.parse(event.data)
        notificationList.value.unshift(noti)
        hasNewMessage.value = true
      }
    })
  }, 3000)
}

onBeforeMount(async () => {
  startSSEMessager()
})

onBeforeUnmount(() => {
  if (eventSource) eventSource.close()
})
</script>
```

### 优化后的代码
```vue
<script setup lang="ts">
import { sseManagerSingleton } from '@/utils/sseManager'
import { SystemNotification } from '@/api/types'

// 使用优化后的SSE管理器
const sseManager = sseManagerSingleton.getManager(
  `${import.meta.env.VITE_API_BASE_URL}system/message`,
  {
    backgroundCloseDelay: 5000, // 5秒后关闭后台连接
    reconnectDelay: 3000,
    maxReconnectAttempts: 3
  }
)

// 消息处理函数
function handleMessage(event: MessageEvent) {
  if (event.data) {
    const noti: SystemNotification = JSON.parse(event.data)
    notificationList.value.unshift(noti)
    hasNewMessage.value = true
  }
}

onBeforeMount(async () => {
  // 延迟3秒后添加监听器
  setTimeout(() => {
    sseManager.addMessageListener('user-notification', handleMessage)
  }, 3000)
})

onBeforeUnmount(() => {
  // 移除监听器（如果没有其他监听器，会自动关闭连接）
  sseManager.removeMessageListener('user-notification')
})
</script>
```

## 2. 定时器优化

### 原始代码（App.vue）
```vue
<script setup lang="ts">
let backgroundRotationTimer: NodeJS.Timeout | null = null

function startBackgroundRotation() {
  if (backgroundRotationTimer) clearInterval(backgroundRotationTimer)
  
  if (backgroundImages.value.length > 1) {
    backgroundRotationTimer = setInterval(() => {
      const nextIndex = (activeImageIndex.value + 1) % backgroundImages.value.length
      preloadImage(backgroundImages.value[nextIndex]).then(success => {
        if (success) {
          activeImageIndex.value = nextIndex
        }
      })
    }, 10000)
  }
}

onMounted(() => {
  startBackgroundRotation()
})

onUnmounted(() => {
  if (backgroundRotationTimer) {
    clearInterval(backgroundRotationTimer)
    backgroundRotationTimer = null
  }
})
</script>
```

### 优化后的代码
```vue
<script setup lang="ts">
import { addBackgroundTimer, removeBackgroundTimer } from '@/utils/backgroundManager'

function rotateBackground() {
  if (backgroundImages.value.length > 1) {
    const nextIndex = (activeImageIndex.value + 1) % backgroundImages.value.length
    preloadImage(backgroundImages.value[nextIndex]).then(success => {
      if (success) {
        activeImageIndex.value = nextIndex
      }
    })
  }
}

function startBackgroundRotation() {
  // 使用后台管理器，自动处理前台/后台切换
  addBackgroundTimer(
    'background-rotation',
    rotateBackground,
    10000, // 10秒间隔
    {
      runInBackground: false, // 后台时不运行
      skipInitialRun: true
    }
  )
}

onMounted(() => {
  startBackgroundRotation()
})

onUnmounted(() => {
  removeBackgroundTimer('background-rotation')
})
</script>
```

## 3. 仪表盘数据刷新优化

### 原始代码（AnalyticsMemory.vue）
```vue
<script setup lang="ts">
let refreshTimer: NodeJS.Timeout | null = null

async function loadMemoryInfo() {
  try {
    const res: MemoryInfo = await api.get('dashboard/memory')
    memoryInfo.value = res
  } catch (error) {
    console.error('Failed to load memory info:', error)
  }
}

onMounted(async () => {
  await loadMemoryInfo()
  refreshTimer = setInterval(loadMemoryInfo, 3000)
})

onUnmounted(() => {
  if (refreshTimer) {
    clearInterval(refreshTimer)
    refreshTimer = null
  }
})
</script>
```

### 优化后的代码
```vue
<script setup lang="ts">
import { addBackgroundTimer, removeBackgroundTimer } from '@/utils/backgroundManager'

async function loadMemoryInfo() {
  try {
    const res: MemoryInfo = await api.get('dashboard/memory')
    memoryInfo.value = res
  } catch (error) {
    console.error('Failed to load memory info:', error)
  }
}

onMounted(async () => {
  // 立即加载一次
  await loadMemoryInfo()
  
  // 添加定时刷新，后台时自动暂停
  addBackgroundTimer(
    'memory-refresh',
    loadMemoryInfo,
    3000, // 3秒间隔
    {
      runInBackground: false, // 后台时不刷新
      skipInitialRun: true // 已经手动加载过了
    }
  )
})

onUnmounted(() => {
  removeBackgroundTimer('memory-refresh')
})
</script>
```

## 4. PWA状态管理优化

### 原始代码（pwaStateManager.ts）
```typescript
private setupPeriodicSave(): void {
  // 每30秒保存一次状态
  setInterval(() => {
    if (!document.hidden) {
      this.saveCurrentState()
    }
  }, 30000)
}
```

### 优化后的代码
```typescript
import { addBackgroundTimer } from '@/utils/backgroundManager'

private setupPeriodicSave(): void {
  // 使用后台管理器，延长间隔并添加用户活跃检查
  addBackgroundTimer(
    'pwa-state-save',
    () => {
      // 只在用户活跃时保存状态
      if (this.isUserActive()) {
        this.saveCurrentState()
      }
    },
    60000, // 改为60秒
    {
      runInBackground: false, // 后台时不保存
      skipInitialRun: true
    }
  )
}

private isUserActive(): boolean {
  // 检查用户是否在最近5分钟内有活动
  const lastActivity = this.getLastActivityTime()
  return Date.now() - lastActivity < 300000
}

private getLastActivityTime(): number {
  // 可以从后台管理器获取最后活动时间
  return backgroundManager.getLastActivityTime()
}
```

## 5. 统一的组件优化模式

### 创建一个通用的组合函数
```typescript
// src/composables/useBackgroundOptimization.ts
import { onMounted, onUnmounted } from 'vue'
import { sseManagerSingleton } from '@/utils/sseManager'
import { addBackgroundTimer, removeBackgroundTimer } from '@/utils/backgroundManager'

export function useBackgroundOptimization() {
  // SSE连接管理
  const useSSE = (url: string, messageHandler: (event: MessageEvent) => void, listenerId: string) => {
    const manager = sseManagerSingleton.getManager(url)
    
    onMounted(() => {
      manager.addMessageListener(listenerId, messageHandler)
    })
    
    onUnmounted(() => {
      manager.removeMessageListener(listenerId)
    })
    
    return manager
  }

  // 定时器管理
  const useTimer = (
    id: string,
    callback: () => void,
    interval: number,
    options?: {
      runInBackground?: boolean
      skipInitialRun?: boolean
    }
  ) => {
    onMounted(() => {
      addBackgroundTimer(id, callback, interval, options)
    })
    
    onUnmounted(() => {
      removeBackgroundTimer(id)
    })
  }

  return {
    useSSE,
    useTimer
  }
}
```

### 使用通用组合函数
```vue
<script setup lang="ts">
import { useBackgroundOptimization } from '@/composables/useBackgroundOptimization'

const { useSSE, useTimer } = useBackgroundOptimization()

// 使用SSE
useSSE(
  `${import.meta.env.VITE_API_BASE_URL}system/message`,
  (event: MessageEvent) => {
    // 处理消息
  },
  'component-sse'
)

// 使用定时器
useTimer(
  'component-timer',
  () => {
    // 定时执行的任务
  },
  5000,
  { runInBackground: false }
)
</script>
```

## 6. 调试和监控

### 添加开发工具
```typescript
// src/utils/backgroundDebug.ts
import { backgroundManager } from '@/utils/backgroundManager'

export function createBackgroundDebugger() {
  if (import.meta.env.DEV) {
    // 在开发环境中添加全局调试函数
    ;(window as any).backgroundDebug = {
      getStatus: () => backgroundManager.getStatus(),
      getTimersInfo: () => backgroundManager.getTimersInfo(),
      logStatus: () => {
        console.table(backgroundManager.getTimersInfo())
        console.log('Background Status:', backgroundManager.getStatus())
      }
    }
    
    // 定期输出状态信息
    setInterval(() => {
      if (backgroundManager.getStatus().timerCount > 0) {
        console.log('Background timers:', backgroundManager.getTimersInfo())
      }
    }, 30000)
  }
}
```

### 在main.ts中启用调试
```typescript
// src/main.ts
import { createBackgroundDebugger } from '@/utils/backgroundDebug'

// 启用后台调试
createBackgroundDebugger()
```

## 7. 性能监控

### 添加性能统计
```typescript
// src/utils/performanceMonitor.ts
export class PerformanceMonitor {
  private metrics: {
    sseConnections: number
    activeTimers: number
    backgroundSwitches: number
    lastBackgroundTime: number
  } = {
    sseConnections: 0,
    activeTimers: 0,
    backgroundSwitches: 0,
    lastBackgroundTime: 0
  }

  constructor() {
    this.setupMonitoring()
  }

  private setupMonitoring() {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.metrics.backgroundSwitches++
        this.metrics.lastBackgroundTime = Date.now()
      }
    })
  }

  getMetrics() {
    return { ...this.metrics }
  }

  logMetrics() {
    console.log('PWA Performance Metrics:', this.getMetrics())
  }
}

export const performanceMonitor = new PerformanceMonitor()
```

这些优化方案可以显著减少PWA应用在iOS后台的资源消耗，提高应用的生存能力。关键在于：

1. **SSE连接在后台自动关闭**，前台时自动重连
2. **定时器在后台自动暂停**，前台时自动恢复
3. **统一的后台活动管理**，避免资源浪费
4. **用户活跃状态检测**，只在必要时执行后台任务

建议优先实施SSE连接优化和定时器优化，这两项改动可以立即看到效果。